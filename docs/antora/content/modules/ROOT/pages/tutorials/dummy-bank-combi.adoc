= Dummy Bank Combi tutorial
:page-pagination:
:description: Learn how to model and test the Dummy Bank website by using 2 of Provengo's libraries - `StateMachines` and `Combi`.
:keywords: Libraries, Combi, StateMachines, Dummy Bank, Dummy Bank Combi, sealed fate pattern


//variables

:combi: The Combi library enables specification developers to define specification parameters, and the way they interact with each other and with the expected system behavior in general.

:stateMachines: The StateMachines library is used to describe systems in a form of a state machine.

:constraints: This library allows QA analysts to declaratively limit or require occurrences of events or event sets.

//links 
:linkCombiLib: https://docs.provengo.tech/main/site/ProvengoCli/0.9.5/libraries/combi.html
:linkSMLib: https://docs.provengo.tech/main/site/ProvengoCli/0.9.5/libraries/stateMachines.html
:linkConstraintsLib: https://docs.provengo.tech/main/site/ProvengoCli/0.9.5/libraries/constraints.html

:linkDummyBankSite: https://dummy-bank.provengo.tech/login
:link-companion-code-repo: https://github.com/Provengo/TutorialsCodeCompanion/
:LinkCreateNewProjectTutorial: file:///Users/sivanpeer/Documents/code/provengo/Tutorials/docs/antora/build/site/Tutorials/0.1/index.html


:selenium-install-link: https://docs.provengo.tech/main/site/ProvengoCli/0.9.5/installation.html


In this tutorial we'll learn how to build a test model for a queue scheduling application for a bank. 
We'll be building a behavioral model of the SUT by using two of Provengo's libraries - {linkSMLib}[*`stateMachines`*^,title={stateMachines},role=green] and {linkCombiLib}[*`combi`*^,title={combi},role=green]. 



// The model we are going to build has 2 core layers- the case paramteres and the user flow which is the high level of the system. and a 3rd layer for the automation. Every layer is responsible for describing and handling a different part of the SUT and together they construct the full system's behavior. 


The tested site is available at https://dummy-bank.provengo.tech[Provengo Dummy Bank].
// You can find a comprehensive overview of it at file:///Users/sivanpeer/Documents/code/provengo/Tutorials/docs/antora/build/site/Tutorials/0.1/tutorials/dummy-bank.html[Dummy Bank Introduction].


// Sealed Fate Pattern::
// This pattern is a method for modeling in which we first model as combi for the case parameters and Then we have them constrain the state machine flow. 

// Model as combi for the case parameters, and a state machine for the user flow. Have the decisions that the combi makes constrain the flow of the state machine (sealed fate pattern).
//specification parameters

// > Needs to be edited.

When completing this tutorial you'll know::

- How to create a model for the bank scheduler website.

- How to use both libraries and how to combine them on the same project.
        
    ** How to use the `Combi` library to describe and determine the case parameters of the model.
        
    ** How to use the `StateMachines` library to create the main flow.
        
    ** How the choices made by `Combi` constrain the website's flow. 

- How to use the created model to generate the test plan and visualize it.

- How to add the automation layer to the model.

// - How to optimize your tests-suite and execute it.

// - How to generate a test execution report. 
     
This is useful because::

* This is a full example solution for a real-world use case.  

* You'll learn how to use different Provengo libraries for each part of the model, and combine them together.


## Project Overview

First, We will use the Combi library to define the specification parameters. On the second step, we'll define the main user flow by using the StateMachines library. 
And then, we will see how to coordinate between the two parts of the model so that the values that were selected by the combi constrain the user flow.

TIP: We call this method of modelling *_Sealed Fate Pattern_* because the user flow is pre-determined by the combi selections. Meaning it's fate is sealed and won't change during the flow.

After coordinating between the 2 parts of the model, we will see how it is being used to generate the test-space. 
And finally, we'll move on to adding an automation layer to the model. 

NOTE: This tutorial covers one of many possible solutions. Feel free to come up with your own solution (don't forget to share it with our community). +
For the sake of a clear and clean tutorial, we'll only go over the main points of the solution.
Check out the {link-companion-code-repo}[companion code repo] to see the full solution.



// Then, we will add the case-parameters to the model. 



// xref:../dummy-bank.adoc[More information about the tested site]

// In this tutorial we will cover the following steps

// // 1. Preparing the workspace and setting up a new Provengo project. 
// 1. Defining the case parameters using the combi library.
// 2. Defining the user flow using StateMachines library.
// 3. Connecting both parts and having the decisions made by combi constrain the user flow. 
// 4. Adding the automation layer to the project.
// 5. Using the model we've just created to generate tests, execute them, view the results, etc...

// We'll be working with 3 main files in our `spec/js` folder:

//     1. `case-params.js` 
//     2. `user-flow.states.js`
//     3. `z-main.js`


Open a new Provengo project. Go to {LinkCreateNewProjectTutorial}[create new provengo project tutorial] if you need help in creating a new project.  


## Define the case parameters

create a new file under the `spec/js` folder. You can name the file `case-params.js`.

IMPORTANT: During this tutorial we will use certain file names, to best keep track of the tutorial, we reccomand using the same names. You can of course use whatever names you want as long as the order of loading is correct. 


In this file we'll be using the `Combi` library to describe the specification parameters and the way they interact with each other.



=== *Define the Combi object*


[source, javascript]
----
// @provengo summon combi <.>

const bank = Combi("Dummy Bank"); <.>
----

<.> To use the `combi` library, summon it at the beginning of the file. 
<.> Create a Combi object with the name _Dummy Bank_. + 
We'll be using it to describe the different options for each entity in the bank app.

=== *Add combi fields*

Now let's use some of the _combi library_ functions to create the different fields and their values. 

TIP: Basically, we need a Combi field for each decision that should be made on the user flow.

. Use the `combi.field(name)` method to create fields for both the service and the topic the user wants for his meeting.
    ** *service* - choose the desired service for the meeting - a banker, an investment specialist or a cashier. 
    ** *topic* - choose the desired topic for the meeting, each service has different topics. 
. Add values to each field with the `fld.isOneOf(v1,v2…​/arr)` function. 

[source, javascript]
----
// define the service field and set it's different values.
const service = bank.field("service").isOneOf("Banker", "Cashier", "Investment Specialist"); 

// definde the topic field and set it's different values.
const topic = bank.field("topic").isOneOf(TOPICS);
----

Now the variable `topic` holds the full topics list. We need to limit thier values by the services. 

Let's define some fields dependencies by using the `fld.whenSetTo(x).field(f2).mustBe(y)` function.
This will connect the different services to their corelated topics.

[source, javascript]
----
<.> 
service.whenSetTo("Banker")
      .field(topic).mustBe(MEETING_TYPE_2_TOPIC["meet_banker"]); 
<.> 
service.whenSetTo("Investment Specialist")
      .field(topic).mustBe(MEETING_TYPE_2_TOPIC["meet_invest"]);
<.>
service.whenSetTo("Cashier")
      .field(topic).mustBe(MEETING_TYPE_2_TOPIC["meet_cashier"]);
----
<.> Set the topic values for a meeting with a banker. 
<.> Set the topic values for meeting with an investment specialist. 
<.> Set the topic values for meeting with a cashier. 


[TIP]
====
You can find _TOPICS_, _MEETING_TYPE_2_TOPIC_ in the `data/data.js` file. + 
You can do the same for the services. that's just another way of using it. 
====

* Let's add the fields we need for setting up the time for the meeting. 
    ** *dayPart* choose between morning and afternoon panels. 
    ** *hour* choose the desired hour according to the day part. 

[source, javascript]
----
const dayPart = bank.field("dayPart").isOneOf(DAYPART);
const hour = bank.field("hour").isOneOf(HOURS);
----

* Use `fld.whenSetTo(x).field(f2).mustBe(y)` again, to connect between dayparts and their correlated hours.


[source, javascript]
----
dayPart.whenSetTo("morning").field(hour).cannotBe(DAYPART_2_TIME["afternoon"]);
dayPart.whenSetTo("afternoon").field(hour).cannotBe(DAYPART_2_TIME["morning"]);
----

// - branch - to set the branch when it's not defaulted to Home Branch. 
    * Add a field to set the branch and it's values. 
    ** *branch* choose a branch for the meeting.

[source, javascript]
----
const branch = bank.field("branch").isOneOf(REMOTE_BRANCHES);
----

NOTE: When the selected service is either a banker or an investments specialist, the branch defaults to _home branch_.

Let's constrain the branch to be _Home Branch_ when the chosen service is not _Cashier_. 

[source, javascript]
----
service.whenSetTo("Banker").field(branch).mustBe("Home Branch");
service.whenSetTo("Investment Specialist").field(branch).mustBe("Home Branch");
----

Create a `recordCombiValues` function.
This function uses the `record` function to save the values that were chosen by _Combi_ so we can use it later for automation.  

[source, javascript]
----
function recordCombiValues() {
  hour.record();
  topic.record();
  branch.record();
  dayPart.record();
  service.record();
}
----

Add the below code to start the process of setting the combi parameters.

[source, javascript]
----
bank.doStart();
----

And that's it. we're done with the file that handles case parameters. + 
Let's make sure that everything is working properly. 


=== *Test Space*

Go to your terminal and run the `analyze` sub-command to visualize the test space the combi has created. 

[source,bash]
----
provengo analyze -f pdf /dummy-bank-combi

# Replace `/dummy-bank-combi` with the path to your project.
----


=> You should get a new `testSpace.pdf` file under the `products/run-source` folder. +
It should open automatically for you, and you should see something like this: 

image:dummy-bank-combi/analyze1.png["analyze result"]

As you can see in the graph, each field we've created has 2 pentagons representing it; one is facing inwards and the other one outwards, symbolizing the start event and the end event respectively. In between the pentagons we can see the edges representing the different options that we earlier set to each field.  



## Define the user flow
Let's move on to creating the file that handles the user flow.

In this file, or this part of the model, we'll be using the _StateMachines_ library to define a state machine that describes the user flow. 



//few wrds the user needs to _login_ with a valid usename and password, then he needs to select the servec....

=== *States and Transitions*

First, let's identify the different states and transitions of the bank scheduler app.

TIP: *States* represent the different screens or stages of the application. +
    *Transitions* are the events or actions that cause the app to move from one state to another.

=== *The main flow*

image:dummy-bank/flow.png["flow"]



### *Define the State Machine*

Create a new file under the `spec/js` folder and call it `user-flow.js`.


[source,js]
----
// @provengo summon StateMachines <.>

const sm = new StateMachine("Dummy Bank Example",false); <.>
----

<.> To use the `StateMachines` library, summon it at the beginning of the file 
<.> Define the state machine object, with the `StateMachine(name, properties)` function. Call it `Dummy Bank Example` and set the `autoStart` property to false.


### *Connect The States*
Use the function `sm.connect(s1).to(s2)` to create and connect the states to each other, according to the transitions we saw earlier. 

By default, the first state defined through connect is the starting state.
We need 2 starting points:

    .. for the _login_ state.

    .. for the _chooseTopic_ state to allow connecting the _setTimeAndBranch_ state to the machine. 
    
TIP: Use the `sm.connect(s1).to(s2)` to allow connecting multiple states to an existing one. + 

[source,js]
----
sm.connect("login")
    .to("dashboard")
    .to("chooseService")
    .to("chooseTopic")
    .to("setTime")
    .to("contactInfo")
    .to("userConfirmation")
    .to("systemConfirmation");

sm.connect("chooseTopic")
    .to("setTimeAndBranch")
    .to("contactInfo");

----


=== *Add constraints to the main flow*

Next, we want the state machine to make the correct transitions according to the selected service. We'll be using the {linkConstraintsLib}[*`constraints`*^,title={constraints},role=green] library to set these transition. 

[NOTE]
====
To use the `constraints` library, summon it at the beginning of the file
====

[source,js]
----
// @provengo summon constraints
----



. Let's block the state machine from entering to the `setTimeAndBranch` state when the selected service is either a banker or an investments specialist.
. Let's block the state machine from entering the `setTime` state when the selected service is cashier. 


[source,js]
----
Constraints.after(service.setToEvent("Banker"))
            .block(sm.enterEvent("setTimeAndBranch"))
            .until(sm.enterEvent("contactInfo"));

Constraints.after(service.setToEvent("Investment Specialist"))
            .block(sm.enterEvent("setTimeAndBranch"))
            .until(sm.enterEvent("contactInfo"));<.>
            
Constraints.after(service.setToEvent("Cashier"))
            .block(sm.enterEvent("setTime"))
            .until(sm.enterEvent("contactInfo"));<.>
----

* Let's add a function to get the state machine so it will be available from other files. 

[source,js]
----
function getSm(){
    return sm;
}
----

=== *Test Space*

Let's check out the test space that the state machine produces.

. Change the `autoStart` property of the state machine to true.
. Go to the `case-params.js` file and delete the code that starts the combi. (Or just drag the file to the disabled folder.)
. Open your terminal and use the `analyze` command.

[source,bash]
----
provengo analyze -f pdf /dummy-bank-combi
----

[.text-center]
image:dummy-bank-combi/testSpaceSM.png["analyze result",200px,align="center"]

As we can see, the created graph describes the flow of the app. You can see how the code we wrote translates into the test space, showing all the available scripts and the splits created by the constraints. 


== Coordinate between parts of the model

Up to this point we have seen each part seperately.
Let's move on to creating the code that coordinates between them. 

Create a new file under the `spec/js` folder and call it `z-main.js`. + 
This file will include the main b-thread that is responsible for running the combi and state machine and to make them work together. 

TIP: The files under the `spec/js` folder are being loaded by alphabetic order. We want the main file to be loaded last so we've prefixed it with a `z-`.


Create two constants to indicate whether to run the combi and state machine. 

[source,js]
----
/**  Run the case parameters combi */
const RUN_COMBI = true;
/**  Run the state machine */
const RUN_SM    = true;
----

NOTE: From now on we'll be using these two constants to control the autoStart variables of both the combi and the state machine.
Go to the `user-flow.js` file and set the autoStart property of the stateMachine back to `false`.


=== *Define the main b-thread*

Let's create the main b-thread. It will first run the combi to choose the case parameters, then it will run the state machine with the selected values. 

[source,js]
----
bthread("main", function start() {
  if ( RUN_COMBI ){
    bank.doStart(); <.>
    waitFor(bank.doneEvent); <.>
  } 
  if ( RUN_SM ) {
    const sm = getSm(); <.>
    sm.doStart(); <.>
  } 
});
----
<.> If the `RUN_COMBI` is set to `true`, start the process of setting the bank combi object parameters. 
<.> Wait until the combi arrives to the doneEvent and finishes. 

<.> if the `RUN_SM` is set to `true`, get the state machine by using the `getSm()` function we've created earlier in the `user-flow.js` file.
<.> Start the state machine. 

The code above creates the behavior of the _sealed fate pattern_ by first running the combi to select all the case paramters and only then running the state machine and having the selected values constraining the user flow. 


=== *Test Space*
Let's produce the test space again, this time, for the complete model. 

[source,bash]
----
provengo analyze -f pdf /dummy-bank-combi
----

image:dummy-bank-combi/testSpaceFull.png["analyze result"]
// TODO -  rephrase
As you can see in the graph, the model first chooses the case parameters values. and only when the combi is done, it moves to the state machine, and continues linearily, no parameters are being selcted in the process, decisions were alredy taken on the combi part of the model.  

## Automation
_In this section, we will explain some of the automation process. For a full solution go to the companion repo._

IMPORTANT: For the automation to work, you need a running selenium server available from your machine. The simplest way is to run them locally. See {selenium-install-link}[here] for installation instructions.

To add automation to the process, create a new file under spec/js folder and call it `z-low-level.js`.

In this file we define the automation steps for each state of the state machine. 
We will first see how to connect the states to their related fuctions. Then, we will define the handlers and fill them with the steps we need for automating the dummy bank website. 

TIP: We want this file to be loaded after the files that define the combi and the state machine, so we've prefixed it with the letter `z-`. 


=== *Get combi values*
Let's make sure that the values that were selected by combi will be available for the automation steps. 

[source,js]
----
// @provengo summon selenium <.>

recordCombiValues(); <.>
----
<.> To Use the Selenium library summon it at the beginning of the file.
<.> Call the `recordCombiValues` function that we earlier defined on the `case-params.js` file.

=== *Link each state to its handler function*

Next, we would like to link each state of the state machine to a function that handles it's automation. 

Use the function `sm.at(stateName).run(handler)`. It will run the `handler` whenever it gets to the state `stateName`.

NOTE: You can find the available selenium functions in the https://docs.provengo.tech/main/site/ProvengoCli/0.9.5/libraries/selenium.html[documantaion].


[source,js]
----

getSm().at("login").run(userLogin);
getSm().at("dashboard").run(dashboard);
getSm().at("chooseService").run(chooseService);
getSm().at("chooseTopic").run(chooseTopic);

getSm().at("setTime").run(setTime);
getSm().at("setTimeAndBranch").run(setTimeAndBranch);

getSm().at("contactInfo").run(contactInfo);
getSm().at("userConfirmation").run(userConfirmation);
getSm().at("systemConfirmation").run(systemConfirmation);
----
// <.> userLogin and dashboard
// <.>
// <.>

=== *The state handler functions*
Before we implement the handler functions, we need to define a new session. 

[source,js]
----
const session = new SeleniumSession("session");
----

Let's add handlers for the _login_ and the _dashboard_ states. 

[source,js]
----
function userLogin() { 
  session.start(URL); <.>
  session.writeText(COMPONENTS.LOGIN.userName,  CUSTOMER_DETAILS.username); <.>
  session.writeText(COMPONENTS.LOGIN.password, CUSTOMER_DETAILS.password);
  session.click(COMPONENTS.LOGIN.submitButton); <.>
}

function dashboard() {
  session.waitForVisibility(COMPONENTS.dashboard, 1000); <.>
}
----
<.> Start the session with the URL of the dummy bank app. 
<.> Enter credentials to login.
<.> Click the login button.
<.> Wait for the dashboard component to be visible. 

Now Let's define the _chooseService_ and _chooseTopic_ handlers: 
After we've saved the combi values, let's retrive them into local variables for automating.

TIP: Variable names should be unique across the files of the project. A good practice will be to call the retrived value of a field `x` => `selectedX`. [ See (2) below ]


[source,js]
----
function chooseService() {
  if (!bp.store.has(service.name)) { <.>
    return;
  }

  let selectedService = bp.store.get(service.name); <.>
  let button;

  if (selectedService == "Banker") { <.>
    button = COMPONENTS.SERVICES.meet_banker;
  } else if (selectedService == "Cashier") {
    button = COMPONENTS.SERVICES.meet_cashier;
  } else {
    button = COMPONENTS.SERVICES.meet_invest;
  }
  session.click(button); <.>
}

function chooseTopic() {
  let button;
  if (!bp.store.has(topic.name)) {
    return;
  }

  let selectedTopic = String(bp.store.get(topic.name)); <.>

  if (selectedTopic.includes("1")) { <.>
    button = COMPONENTS.TOPICS.topic_1;
  } else if (selectedTopic.includes("2")) {
    button = COMPONENTS.TOPICS.topic_2;
  } else if (selectedTopic.includes("3")) {
    button = COMPONENTS.TOPICS.topic_3;
  } else {
    button = COMPONENTS.TOPICS.topic_4;
  }

  session.click(button); <.>
}


----
<.> Check if the service value exists.
<.> Save it to a variable called `selectedService`
<.> Change the button value according to the `selectedService` value.
<.> Click the selected service button. 
<.> Cast the type of the retrieved value to a String, so you can use the String method `includes()` on it. 
<.> Let's check what topic number button should be clicked. 
<.> Click the selected topic button. 


Continue adding the rest of the handlers on your own, or use the {exmpale-solution}[example solution] to finish the automation.

=== *Run* 



To run the project and see the automation process, open your terminal and type the following command:

[source,bash]
----
provengo run --show-sessions /dummy-bank-combi
----

An automated browser-window will open and you will be able to see a specific scenario being executed. 